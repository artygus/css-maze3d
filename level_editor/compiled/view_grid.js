// Generated by CoffeeScript 1.7.1

/*
  Level grid
 */

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  levelEditor.view.Grid = (function(_super) {
    __extends(Grid, _super);

    Grid.prototype.DT = "levelEditor.view.Grid";

    function Grid(app) {
      this.app = app;
      this.getBlockXYByGridXY = __bind(this.getBlockXYByGridXY, this);
      this.getBlockId = __bind(this.getBlockId, this);
      this.getGridXYByBlockXY = __bind(this.getGridXYByBlockXY, this);
      this.getGridXY = __bind(this.getGridXY, this);
      this.templateRow = __bind(this.templateRow, this);
      this.templateCell = __bind(this.templateCell, this);
      this.templateBlock = __bind(this.templateBlock, this);
      this.template = __bind(this.template, this);
      this.handleGridPosition = __bind(this.handleGridPosition, this);
      this.interactionMouseMove = __bind(this.interactionMouseMove, this);
      this.positionGrid = __bind(this.positionGrid, this);
      this.positionBlock = __bind(this.positionBlock, this);
      this.renderGridBlock = __bind(this.renderGridBlock, this);
      this.drawBlock = __bind(this.drawBlock, this);
      this.drawVisibleBlock = __bind(this.drawVisibleBlock, this);
      this.drawGridPosition = __bind(this.drawGridPosition, this);
      this.drawInitialBlock = __bind(this.drawInitialBlock, this);
      this.drawInitially = __bind(this.drawInitially, this);
      this.stateInit = __bind(this.stateInit, this);
      Grid.__super__.constructor.apply(this, arguments);
      console.log(this.DT, "Init.");
      this.dUiModes = this.app.data.get("ui-modes");
      this.stateInit();
      this.interactionMouseMove();
      this.drawInitially();
    }

    Grid.prototype.stateInit = function() {
      this.state = new chms.ard.AbstractReactiveData();
      this.state.set("gridBlockSize", null);
      this.state.set("gridX", 0);
      this.state.set("gridY", 0);
      this.state.set("blocks", {});
      return $(this.state).on(this.app.data.s.I_DATA_CHANGED, (function(_this) {
        return function(v) {
          switch (v.key) {
            case "gridX":
            case "gridY":
              _this.drawGridPosition();
              return _this.drawVisibleBlock();
          }
        };
      })(this));
    };

    Grid.prototype.MAX_GRID_BLOCKS = 5;

    Grid.prototype.GRID_BLOCK_SIZE = 100;

    Grid.prototype.drawInitially = function() {
      this.el = $(this.template());
      this.app.el.append(this.el);
      this.drawGridPosition();
      this.drawInitialBlock();
      return new levelEditor.view.Cells(this.el, this.app);
    };

    Grid.prototype.INITIAL_BLOCK_XY = [2, 2];

    Grid.prototype.drawInitialBlock = function() {
      var bxy, gxy;
      bxy = this.INITIAL_BLOCK_XY;
      this.drawBlock(bxy[0], bxy[1]);
      gxy = this.getGridXYByBlockXY(bxy[0], bxy[1]);
      gxy = this.handleGridPosition(-gxy[0], -gxy[1]);
      this.state.set("gridX", gxy[0]);
      return this.state.set("gridY", gxy[1]);
    };

    Grid.prototype.drawGridPosition = function() {
      var xy;
      xy = this.getGridXY();
      return this.positionGrid(xy[0], xy[1]);
    };

    Grid.prototype.drawVisibleBlock = function() {
      var bid, block, bxy, key, visible, windowh, windoww, xy, xyBottomLeft, xyBottomRight, xyTopLeft, xyTopRight, xys, _i, _len, _ref, _results;
      xy = this.getGridXY();
      windoww = $(window).width();
      windowh = $(window).height();
      xyTopLeft = [-xy[0], -xy[1]];
      xyTopRight = [xyTopLeft[0] + windoww, xyTopLeft[1]];
      xyBottomLeft = [xyTopLeft[0], xyTopLeft[1] + windowh];
      xyBottomRight = [xyTopRight[0], xyBottomLeft[1]];
      xys = [xyTopLeft, xyTopRight, xyBottomLeft, xyBottomRight];
      visible = [];
      for (_i = 0, _len = xys.length; _i < _len; _i++) {
        xy = xys[_i];
        bxy = this.getBlockXYByGridXY(xy[0], xy[1]);
        bid = this.getBlockId(bxy[0], bxy[1]);
        if (this.state.get("blocks")[bid] == null) {
          this.drawBlock(bxy[0], bxy[1]);
        }
        block = this.state.get("blocks")[bid];
        block.show();
        visible.push(block);
      }
      _ref = this.state.get("blocks");
      _results = [];
      for (key in _ref) {
        block = _ref[key];
        if (visible.indexOf(block) === -1) {
          _results.push(block.hide());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Grid.prototype.drawBlock = function(blockx, blocky) {
      var b;
      b = $(this.renderGridBlock());
      this.el.append(b);
      if (this.state.get("gridBlockSize") == null) {
        this.state.set("gridBlockSize", b.width());
      }
      this.positionBlock(b, blockx, blocky);
      this.state.get("blocks")[this.getBlockId(blockx, blocky)] = b;
      return b;
    };

    Grid.prototype.renderGridBlock = function() {
      var block, cols, i, ii, j, rows, _i, _j, _ref, _ref1;
      rows = "";
      for (i = _i = 1, _ref = this.GRID_BLOCK_SIZE; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        cols = '';
        ii = i.toString();
        for (j = _j = 1, _ref1 = this.GRID_BLOCK_SIZE; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
          cols += this.templateCell(j, ii);
        }
        rows += this.templateRow(cols);
      }
      block = this.templateBlock(rows);
      return block;
    };

    Grid.prototype.positionBlock = function(block, gridx, gridy) {
      var xy;
      xy = this.getGridXYByBlockXY(gridx, gridy);
      return block.css({
        left: xy[0],
        top: xy[1]
      });
    };

    Grid.prototype.positionGrid = function(gridx, gridy) {
      return this.el.css({
        left: gridx,
        top: gridy
      });
    };

    Grid.prototype.interactionMouseMove = function() {
      var mdown, mmove, mouse, mup, prevx, prevy;
      mdown = $(document).asEventStream("mousedown").filter((function(_this) {
        return function(e) {
          return e.which === 1;
        };
      })(this)).map((function(_this) {
        return function() {
          return {
            mstate: "down"
          };
        };
      })(this));
      mup = $(document).asEventStream("mouseup").map((function(_this) {
        return function() {
          return {
            mstate: "up"
          };
        };
      })(this));
      mmove = $(document).asEventStream("mousemove").map((function(_this) {
        return function(v) {
          return {
            x: v.clientX,
            y: v.clientY
          };
        };
      })(this));
      prevx = null;
      prevy = null;
      mup.onValue((function(_this) {
        return function() {
          prevx = null;
          return prevy = null;
        };
      })(this));
      mouse = mdown.merge(mup).combine(mmove, (function(_this) {
        return function(f, s) {
          return $.extend(f, s);
        };
      })(this)).filter((function(_this) {
        return function(v) {
          return v.mstate === "down";
        };
      })(this)).map((function(_this) {
        return function(v) {
          var r;
          if ((prevx != null) && (prevy != null)) {
            r = $.extend(v, {
              offsetx: v.x - prevx,
              offsety: v.y - prevy
            });
          } else {
            r = v;
          }
          prevx = v.x;
          prevy = v.y;
          return r;
        };
      })(this));
      return mouse.filter((function(_this) {
        return function(v) {
          return (v.offsetx != null) && (v.offsety != null);
        };
      })(this)).filter((function(_this) {
        return function() {
          return _this.dUiModes.get("currentMode") === _this.dUiModes.s.MODE_NAVIGATE;
        };
      })(this)).onValue((function(_this) {
        return function(v) {
          var xy;
          xy = _this.getGridXY();
          xy = _this.handleGridPosition(xy[0] + v.offsetx, xy[1] + v.offsety);
          _this.state.set("gridX", xy[0]);
          return _this.state.set("gridY", xy[1]);
        };
      })(this));
    };

    Grid.prototype.handleGridPosition = function(x, y) {
      var dim, max, r, xy, _i, _len, _ref;
      max = -(this.state.get("gridBlockSize") * this.MAX_GRID_BLOCKS);
      xy = [];
      _ref = [x, y];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dim = _ref[_i];
        r = Math.min(0, dim);
        r = Math.max(max, r);
        xy.push(r);
      }
      return xy;
    };

    Grid.prototype.template = function() {
      return "<div class=\"grid\">\n</div>";
    };

    Grid.prototype.templateBlock = function(block) {
      return "<div class=\"grid__block\">\n  " + block + "\n</div>";
    };

    Grid.prototype.templateCell = function(x, y) {
      var xy;
      xy = "x=\"" + x + "\" y=\"" + y + "\"";
      return "<div class=\"grid__col\" " + xy + " cell></div>";
    };

    Grid.prototype.templateRow = function(cols) {
      return "<div class=\"grid__row\">" + cols + "</div>";
    };

    Grid.prototype.getGridXY = function() {
      return [this.state.get("gridX"), this.state.get("gridY")];
    };

    Grid.prototype.getGridXYByBlockXY = function(blockx, blocky) {
      var bs;
      bs = this.state.get("gridBlockSize");
      return [blockx * bs, blocky * bs];
    };

    Grid.prototype.getBlockId = function(blockx, blocky) {
      return "block" + blockx + "-" + blocky;
    };

    Grid.prototype.getBlockXYByGridXY = function(gridx, gridy) {
      var bs;
      bs = this.state.get("gridBlockSize");
      return [Math.floor(gridx / bs), Math.floor(gridy / bs)];
    };

    return Grid;

  })(levelEditor.Object);

}).call(this);
