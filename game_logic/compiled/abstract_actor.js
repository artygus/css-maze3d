// Generated by CoffeeScript 1.7.1

/*
  Abstract actor
 */

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  gameLogic.actors.AbstractActor = (function(_super) {
    __extends(AbstractActor, _super);

    AbstractActor.UID_KEY = "actor";

    AbstractActor.AID_ATTACK = "attack";

    AbstractActor.AID_RECEIVE_DMG = "receive_dmg";

    AbstractActor.AID_DEAD = "dead";

    AbstractActor.prototype.MODEL = models.actors.Empty;

    function AbstractActor(app) {
      this.app = app;
      this.getNextViewpointCell = __bind(this.getNextViewpointCell, this);
      this.getNextDirection = __bind(this.getNextDirection, this);
      this.getStrafeDimensionAndVector = __bind(this.getStrafeDimensionAndVector, this);
      this.getMoveDimensionAndVector = __bind(this.getMoveDimensionAndVector, this);
      this.getPosition = __bind(this.getPosition, this);
      this.assureActorExists = __bind(this.assureActorExists, this);
      this.assureActorInCharge = __bind(this.assureActorInCharge, this);
      this.getModel = __bind(this.getModel, this);
      this.reactDead = __bind(this.reactDead, this);
      this.reactUpdated = __bind(this.reactUpdated, this);
      this.reactActionCompleted = __bind(this.reactActionCompleted, this);
      this.receiveDmg = __bind(this.receiveDmg, this);
      this.actionAttack = __bind(this.actionAttack, this);
      this.calcDmg = __bind(this.calcDmg, this);
      this.isDead = __bind(this.isDead, this);
      this.actionTurnAntiClockwise = __bind(this.actionTurnAntiClockwise, this);
      this.actionTurnClockwise = __bind(this.actionTurnClockwise, this);
      this.actionTurn = __bind(this.actionTurn, this);
      this.actionStrafeRight = __bind(this.actionStrafeRight, this);
      this.actionStrafeLeft = __bind(this.actionStrafeLeft, this);
      this.actionStrafe = __bind(this.actionStrafe, this);
      this.actionMoveBackward = __bind(this.actionMoveBackward, this);
      this.actionMoveForward = __bind(this.actionMoveForward, this);
      this.actionMove = __bind(this.actionMove, this);
      this.performMove = __bind(this.performMove, this);
      this.act = __bind(this.act, this);
      this.actionNoop = __bind(this.actionNoop, this);
      this.performAction = __bind(this.performAction, this);
      this.turnEnded = __bind(this.turnEnded, this);
      this.turnStart = __bind(this.turnStart, this);
      this.initState = __bind(this.initState, this);
      AbstractActor.__super__.constructor.apply(this, arguments);
      this.id = chms.utils.Uniq.gen(this.s.UID_KEY);
      this.data = new gameLogic.data.Actor();
      this.initState();
      $(this.data).asEventStream(this.data.s.I_DATA_CHANGED).filter((function(_this) {
        return function(v) {
          return v.key === "inCharge" && v.value;
        };
      })(this)).onValue(this.act);
    }

    AbstractActor.prototype.initState = function() {};

    AbstractActor.prototype.turnStart = function() {
      return this.data.set("inCharge", true);
    };

    AbstractActor.prototype.turnEnded = function() {
      return this.data.set("inCharge", false);
    };

    AbstractActor.prototype.performAction = function(action) {
      this.assureActorInCharge();
      action();
      return this.reactActionCompleted();
    };

    AbstractActor.prototype.actionNoop = function() {
      return this.performAction((function(_this) {
        return function() {
          return null;
        };
      })(this));
    };

    AbstractActor.prototype.act = function() {};

    AbstractActor.prototype.performMove = function(move) {
      this.assureActorExists();
      this.assureActorInCharge();
      return this.performAction(move);
    };

    AbstractActor.prototype.actionMove = function(forward) {
      if (forward == null) {
        forward = true;
      }
      return this.performMove((function(_this) {
        return function() {
          var dv, newPos, pos;
          pos = _this.getPosition();
          dv = _this.getMoveDimensionAndVector(pos.cell, pos.dir, forward);
          newPos = [pos.cell[0], pos.cell[1]];
          newPos[dv.dim] += dv.vector;
          return _this.app.world.moveActor(_this, newPos);
        };
      })(this));
    };

    AbstractActor.prototype.actionMoveForward = function() {
      return this.actionMove();
    };

    AbstractActor.prototype.actionMoveBackward = function() {
      return this.actionMove(false);
    };

    AbstractActor.prototype.actionStrafe = function(right) {
      if (right == null) {
        right = true;
      }
      return this.performMove((function(_this) {
        return function() {
          var dv, newPos, pos;
          pos = _this.getPosition();
          dv = _this.getStrafeDimensionAndVector(pos.cell, pos.dir, right);
          newPos = [pos.cell[0], pos.cell[1]];
          newPos[dv.dim] += dv.vector;
          return _this.app.world.moveActor(_this, newPos);
        };
      })(this));
    };

    AbstractActor.prototype.actionStrafeLeft = function() {
      return this.actionStrafe(false);
    };

    AbstractActor.prototype.actionStrafeRight = function() {
      return this.actionStrafe();
    };

    AbstractActor.prototype.actionTurn = function(clockwise) {
      var nd, pos;
      if (clockwise == null) {
        clockwise = true;
      }
      this.assureActorExists();
      pos = this.getPosition();
      nd = this.getNextDirection(pos.dir, clockwise);
      return this.app.world.changeActorDirection(this, nd);
    };

    AbstractActor.prototype.actionTurnClockwise = function() {
      return this.actionTurn();
    };

    AbstractActor.prototype.actionTurnAntiClockwise = function() {
      return this.actionTurn(false);
    };

    AbstractActor.prototype.isDead = function() {
      return this.data.get("currentHealth") < 1;
    };

    AbstractActor.prototype.calcDmg = function(diceValue) {
      return 0;
    };

    AbstractActor.prototype.actionAttack = function() {
      return this.performMove((function(_this) {
        return function() {
          var dmg, nc, victim;
          nc = _this.getNextViewpointCell();
          _this.app.world.assureCellExistance(nc);
          _this.app.world.assureCellNonEmpty(nc);
          dmg = _this.calcDmg();
          victim = _this.app.world.getActorByCell(nc);
          victim.receiveDmg(_this, dmg);
          _this.reactActionCompleted();
          _this.reactUpdated();
          return _this.app.world.animationTakesPlace(_this, _this.s.AID_ATTACK);
        };
      })(this));
    };

    AbstractActor.prototype.receiveDmg = function(from, damage) {
      this.assureActorExists();
      this.data.set("currentHealth", this.data.get("currentHealth") - damage);
      this.reactUpdated();
      if (this.isDead()) {
        this.reactDead();
        return this.app.world.animationTakesPlace(this, this.s.AID_DEAD);
      } else {
        return this.app.world.animationTakesPlace(this, this.s.AID_RECEIVE_DMG);
      }
    };

    AbstractActor.I_ACTION_COMPLETED = "action_completed";

    AbstractActor.I_UPDATED = "updated";

    AbstractActor.I_DEAD = "dead";

    AbstractActor.prototype.reactActionCompleted = function() {
      return $(this).trigger(this.s.I_ACTION_COMPLETED);
    };

    AbstractActor.prototype.reactUpdated = function() {
      return $(this).trigger(this.s.I_UPDATED);
    };

    AbstractActor.prototype.reactDead = function() {
      return $(this).trigger(this.s.I_DEAD);
    };

    AbstractActor.prototype.getModel = function() {
      if (this._model == null) {
        this._model = new this.MODEL();
      }
      return this._model;
    };

    AbstractActor.E_ACTOR_NOT_IN_CHARGE = new Error("Actor does not in charge!");

    AbstractActor.prototype.assureActorInCharge = function() {
      if (!this.data.get("inCharge")) {
        throw this.s.E_ACTOR_NOT_IN_CHARGE;
      }
    };

    AbstractActor.prototype.assureActorExists = function() {
      return this.app.world.assureActorExists(this);
    };

    AbstractActor.prototype.getPosition = function() {
      return this.app.world.getActorPosition(this);
    };

    AbstractActor.prototype.getMoveDimensionAndVector = function(cell, direction, forward) {
      var dim, vector, wd;
      if (forward == null) {
        forward = true;
      }
      wd = dataTypes.WorldDirection;
      if (direction === wd.N || direction === wd.S) {
        dim = 1;
      } else {
        dim = 0;
      }
      if (direction === wd.S || direction === wd.E) {
        vector = +1;
      } else {
        vector = -1;
      }
      if (!forward) {
        vector *= -1;
      }
      return {
        dim: dim,
        vector: vector
      };
    };

    AbstractActor.prototype.getStrafeDimensionAndVector = function(cell, direction, right) {
      var dim, vector, wd;
      if (right == null) {
        right = true;
      }
      wd = dataTypes.WorldDirection;
      if (direction === wd.N || direction === wd.S) {
        dim = 0;
      } else {
        dim = 1;
      }
      if (direction === wd.N || direction === wd.W) {
        vector = +1;
      } else {
        vector = -1;
      }
      if (!right) {
        vector *= -1;
      }
      return {
        dim: dim,
        vector: vector
      };
    };

    AbstractActor.prototype.getNextDirection = function(direction, clockwise) {
      var directions, i, nexti, wd;
      if (clockwise == null) {
        clockwise = true;
      }
      wd = dataTypes.WorldDirection;
      directions = [wd.N, wd.E, wd.S, wd.W];
      if (!clockwise) {
        directions.reverse();
      }
      i = directions.indexOf(direction);
      nexti = i + 1;
      if (nexti > (directions.length - 1)) {
        return directions[0];
      } else if (nexti < 0) {
        return directions[directions.length - 1];
      } else {
        return directions[nexti];
      }
    };

    AbstractActor.prototype.getNextViewpointCell = function() {
      var cp, md, pos;
      pos = this.getPosition();
      cp = pos.cell;
      md = this.getMoveDimensionAndVector(cp, pos.dir);
      if (md.dim === 0) {
        return dataTypes.WorldCell.get(cp[0] + md.vector, cp[1]);
      } else {
        return dataTypes.WorldCell.get(cp[0], cp[1] + md.vector);
      }
    };

    return AbstractActor;

  })(gameLogic.Object);

}).call(this);
